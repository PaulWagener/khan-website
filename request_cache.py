import logging

# request_cache is similar to layer_cache, except it only memoizes results
# for each individual request. If you need to cache results for longer than
# a single request, use layer_cache.
#
# _____Explanation by examples:_____
#
# import request_cache
#
# @request_cache.cache_with_key("calculate_user_averages")
# def calculate_user_averages():
#    ...do lots of long-running work...
#    return result_for_cache
#
# Cache using key generated by utility function that
# varies the key based on the function's input parameters:
#
# @request_cache.cache_with_key_fxn(lambda object: "request_cache_key_for_object_%s" % object.id())
# def calculate_object_average(object):
#   ... do lots of long-running work...
#   return result_for_cache

CACHE = {}

def cache_with_key(key):
    def decorator(target):
        def wrapper(*args, **kwargs):
            return request_cache_check_set_return(target, lambda: key, *args, **kwargs)
        return wrapper
    return decorator

def cache_with_key_fxn(key_fxn): 
    def decorator(target):
        def wrapper(*args, **kwargs):
            return request_cache_check_set_return(target, key_fxn, *args, **kwargs)
        return wrapper
    return decorator

def request_cache_check_set_return(
        target, 
        key_fxn, 
        *args, 
        **kwargs):

    key = key_fxn(*args, **kwargs)

    bust_cache = kwargs.get("bust_cache", False)

    if not bust_cache:
        if has(key):
            return get(key)

    result = target(*args, **kwargs)

    # In case the key's value has been changed by target's execution
    key = key_fxn(*args, **kwargs)

    set(key, result)

    return result

def has(key):
    global CACHE
    return key in CACHE

def get(key):
    global CACHE

    if not has(key):
        return None
    
    return CACHE[key]

def set(key, value):
    global CACHE
    CACHE[key] = value
 
def flush():
    global CACHE
    CACHE = {}

class RequestCacheMiddleware(object):
    def __init__(self, app):
        self.app = app    

    def __call__(self, environ, start_response):
        # Clear the cache at the beginning of every request. Since GAE's Python
        # environment is single-threaded per instance, each individual request
        # is guaranteed to start w/ a unique, empty CACHE dict.
        flush()
        return self.app(environ, start_response)

